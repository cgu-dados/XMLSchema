<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/Users/duncan/Classes/StatComputing/XDynDocs/inst/XSL/OmegahatXSL/Todo.xsl" ?> 

<topics xmlns:r="http://www.r-project.org">
<topic>
<title>General</title>
<items>

<item>
readSchema fails for ogckml22.xsd
</item>

<item>
defineClass(pmmlSchema) fails.
<br/>
Ending up with a call o getClassDef() with "" as the name of the class.
This happens as part of processing the ChildParent type.
In the call to defineClassDefinition for this, we get
<r:code>
sapply(i@slotTypes, class)
<r:output><![CDATA[
                   Extension    TableLocatorOrInlineTable 
                   "Element"            "UnionDefinition" 
                  childField                  parentField 
          "SchemaStringType"           "SchemaStringType" 
            parentLevelField                  isRecursive 
          "SchemaStringType" "RestrictedStringDefinition" 
]]></r:output>
</r:code>
We are dying in the 6th of these which is a SchemaStringType.
</item>

<item>
In processing egquery.xsd, eGCQueryResultType doesn't recognize
the maxOccurs for the slot named ResultItem (with @type ResultItemType) and so just has one rather than a list
of them.
<br/>
After we readSchema(), we have the correct information. So it is when we define the class.
The call to createClassRepresentation() returns "ResultItemType" for the second slot
rather than a list of these.  We should define a new RestrictedListType or something
that induces a new class which is a List-Of-ResultItemType objects.
This calls mapSchemaTypeToS().
If this creates a new class description, we have to ensure that is defined.
So we should do this earlier in the process, i.e. recognize the count
and turn the slotType into RestrictedListType in the ClassDefinition.
So this would be done in <r:func>processSchemaType</r:func>.
The problem is that we have a local element there.
So it is legitimate to leave that as is, unaggressively  describing the element.
<r:code>
source("query.R")
e = query[[1]]$eGQueryResult@slotTypes[[2]]
class(e)
e@count
</r:code>
The count is also on the type, but that is a SchemaTypeReference.
This is getting lost when we resolve the reference.
<br/>
This is probably okay and then we recognize that we have a type
and a number of elements. So we could create an intermediate class,
or use a generic list with a filter on the types. This still
needs an intermediate class that extends the generic list type.
<br/>
Is this similar to Authors in biblio.xsd, i.e.
making a class that is a list containing elements of a data type.
</item>


<item status="done">
Use createSOAPConverter to create the fromConverter when we are defining the classes.
<br/>
SnippetType is getting the wrong converter, yet createSOAPConverter for the type is correct.
See kml.R.
In defClass(), the type@slotTypes[[1]] is a PrimitiveSchemaType, not an AttributeDef.
This is because it is coming in indirectly from a field in FeatureType.
When we resolve that, we get a different definition of 
<br/>
Temporarily changed getName() and also had resolve() method for AttributeDef
return the AttributeDef but with the type resolved.
We may need to back these out, but defineClasses() seems to complete.
</item>

<item>
How do we end up wth SchemaComplexType at the top-level of the schema?
We only see them in the XMCDA schema in all our sample schema (see check.R).
It looks like these should turn into ClassDefinition.
For example, the "parameters" type is a sequence and an attribute group.
<br/>
<b>So implement this case in processSchemaType</b>
<br/>
Map the SchemaComplexType in XMCDA to ClassDefinition types.
</item>


<item>
Implement method for createSOAPConverter for SimpleSequenceType.
 UnionDefinition (is this already done generically). 
SchemaGroupType, SchemaComplexType.
<br/>
Do we want to do Element and SimplElement?
<br/>
For SimpleSequenceType, move the code from createArrayClass to <r:func>createSOAPConverter</r:func>
but we need to compute the base type and the type of the elements.
</item>

<item status="done">
In <r:func>genSlotFromConverterCode</r:func>, we are getting the name of the element not the type
for <r:class>LocalElement</r:class>.  See <r:func>getRTypeFromSOAP</r:func>
<br/>
Extended <r:func>getRTypeFromSOAP</r:func> to look at its first argument
and to process a GenericSchemaType and a LocalElement to get the name, then map it.
</item>

<item status="done">
When creating the prototype for a class definition,
make certain we use the default value for an attribute.
<br/>
See SnippetType and vec2Type in kml21.
</item>

<item>
How to get fromXML(node) to recognize that there is a mapping
from the element name to a class when the element name does not
correspond to an actual class?
<br/>
Do we define a class for the element?
<br/>
Problem is multiple elements may map to the same name.
But not at the top-level.  Can we use composite names to identify the class
for internal/local elements.
<br/>
Another approach is store the information about
elements to actual classes in a variable that we can identify
from the root of the document. We know the 
names of the possible root types, so we can create a
variable for each of these. To avoid conflicts, we
could use the namespace URI in the name.
This would be even easier if we could put the schema classes
into  a separate environment, e.g. package.
For example,  in kml21
BalloonStyle corresponds to BalloonStyleType,
and GroundOverlay corresponds to GroundOverlayType.

<br/>
So let's find the Element and SimpleElements in the schema
and get the names of their R types. 
<r:code>
library(XMLSchema); sch = readSchema("~/GitWorkingArea/XMLSchema/inst/samples/kml21.xsd")
e = sapply(sch[[1]], function(x) is(x, "Element") || is(x, "SimpleElement"))
elementMap = sapply(sch[[1]][e], function(x) x@type@Rname)
</r:code>
To see the comparison between the names
<r:code>
cbind(names(sapply(sch[[1]][e], function(x) x@type@Rname)), as.character(sapply(sch[[1]][e], function(x) x@type@Rname)))
</r:code>
<r:var>elementMap</r:var> is the variable we want. We can use the name of the 
node to 
We need to ensure these types are resolved first and then
compute the Rname to be certain we have the correct name.

<br/>
We have defined a method for <r:func>fromXML</r:func> to be given
or to find this map based on  the URI or being explicitly passed
it by value (or by name).
<b>We need to ensure that this is used recursively.</b>
<br/>
We could just append Type to get the class, but this is just a convention
and from the comparison above it doesn't work, styleUrl - URI, kml - KmlType
<br/>
Another approach is to define a 
class for each element that extends the associated type.
Then we define a coerce method for an XMLAbstractNode
<r:code>
setClass("GroundOverlay", contains = "GroundOverlayType")
setAs("XMLAbstractNode", "GroundOverlay", function(from) as(from, "GroundOverlayType"))
</r:code>
<b>Get rid of warning about prototype in setClass call</b>
Then <r:expr>as(ov[[1]], "GroundOverlay")</r:expr> should do its job.
</item>

<item status="fix">
Make the Element classes extend the corresponding type in makeElementClassDef
and not XMLSchemaFakeClass.  Issue with prototypes being  S4 and list and not reconcilable.  
</item>

<item status="done">
define classes correponding to Element objects
<br/>
Make this optional.
<br/>
See defineElementClasses parameter in <r:func>defineClasses</r:func>
and the function named <r:func>defineElementClasses</r:func>.
</item>

<item status="done">
Defining ObjectType in kml21.xsd doesn't use classes ID and NCName.
The PrimitiveSchemaType in <r:expr>sch[[1]]$ObjectType@slotTypes[[1]]@type</r:expr>
has a value for Rname that is "character" and not ID
</item>


<item status="check">
<i>Check SSOAP to see if this has broken anything.</i>

The default value for the ERROR slot in eGQueryResultType should be character(0), not "".
<br/>
The defaultValues in defineClassDefinition() are correct.
Fix makePrototype().
A simple call to prototype(defaults) gets the right thing. What
does it screw up elsewhere.
</item>

<item status="check">
Related to createSOAPConverter(), make certain to deal with mixed
and simple content when we have to pick up the text content from the node.
e.g. SnippetType in kml21
<br/>
See kml.R.  Works for string or character as base class.
</item>


<item status="check">
Create the fromConverter for ClassDefinition and ExtendedClassDefinition.
<br/>
Use createSOAPConverter if possible.
<br/>
Make fromXML handle optional slots, required slots, 
attributes, attribute default values, etc.
<br/>
LatLonBoxType in kml2.1.xsd
Use this as an example of converting an ExtendedClassDefinition into
an R class and a fromConverter.
These elements are optional. So we have to check if they are present.
<br/>
See LatLonBoxType.Rdb in Books/XMLTechnologies/XMLSchema.
<br/>
<b>Works for these</b>
</item>

<item status="done">
Create the enumerated constants for RestrictedStringDefinition.
Make this optionally.
This would create a variable with the same name as the actual value
and be there solely to avoid typos.
<br/>
Document the defineVarEnums.
</item>

<item status="document">
Document CodeGenOpts and provide a constructor function.
</item>

<item status="done">
remove the kml.xml file in inst/samples/
<br/>
in notes/
</item>



<item status="low">
Pretty print the description objects.
Define <r:func>show</r:func> methods.
</item>

<item status="done">
SimpleSequenceType: biblio.xsd and Authors
<br/>
What about this? On my  hand-written notes.
<br/>
We need to create a validity method, converter, 
and also force the definitions of dependent classes.

<br/>
We should be able to move this to <r:func>createSOAPConverter</r:func>
but we need to compute the base type and the type of the elements.
</item>



<item status="medium">
Should we check the validity for length =  0 in
a SimpleSequenceType if the minOccurs is 1.
</item>

<item status="low">
Graphical display of class hierarchy.
</item>


<item status="check">
Default value for Extension.row in pmml is wrong - character(). Should be NULL.
<br/>
We now kill these off too, I believe.
</item>


<item status="done">
What is the difference between SchemaAnyType (fewer occurrences) and AnySchemaType.
<br/>
I have removed the former now. Test!!!!!
</item>

<item status="later" id="string">
Define a "string" class that extends/contains "character".
Problem is that we lose the class of the elements
as they become "character".
</item>

<item status="later">
Have to use a list as the base class for RestrictedListType 
(and SimpleSequenceType) when the element type is a sub-class
of a primitive type, e.g. "string" or "character".  See <ref ref="#string"/>
</item>

</items>
</topic>
</topics>
